#!/usr/bin/env python3
"""
Filter character CSV file by character type (ASCII or CJK).
Reads a CSV file generated by dump_char_csv.py and filters rows based on codepoint type.
"""
import argparse
import csv
import sys
from utils import is_ascii_char, is_cjk_char, is_upper_char, is_lower_char, is_number_char, is_common_cjk_char


def filter_csv(input_csv, char_types, output_csv):
    """
    Filter CSV file by character type.
    
    Args:
        input_csv: Path to input CSV file (from dump_char_csv.py)
        char_types: Comma-separated list of character types ('ascii', 'cjk', 'upper', 'lower', 'number')
        output_csv: Path to output filtered CSV file
    """
    # Parse comma-separated types
    type_list = [t.strip() for t in char_types.split(',')]
    
    # Map type names to filter functions
    type_map = {
        'ascii': is_ascii_char,
        'cjk': is_cjk_char,
        'upper': is_upper_char,
        'lower': is_lower_char,
        'number': is_number_char,
        'common_cjk': is_common_cjk_char
    }
    
    # Validate types and collect filter functions
    filter_funcs = []
    for char_type in type_list:
        if char_type not in type_map:
            valid_types = ', '.join(type_map.keys())
            print(f"Error: Invalid character type '{char_type}'. Must be one of: {valid_types}", file=sys.stderr)
            sys.exit(1)
        filter_funcs.append(type_map[char_type])
    
    try:
        # Read input CSV
        with open(input_csv, 'r', encoding='utf-8', newline='') as infile:
            reader = csv.DictReader(infile)
            fieldnames = reader.fieldnames
            
            if not fieldnames or 'codepoint_dec' not in fieldnames:
                print("Error: Invalid CSV format. Missing 'codepoint_dec' column.", file=sys.stderr)
                sys.exit(1)
            
            # Filter rows and write to output
            filtered_rows = []
            for row in reader:
                try:
                    codepoint = int(row['codepoint_dec'])
                    # Check if codepoint matches any of the filter functions
                    if any(filter_func(codepoint) for filter_func in filter_funcs):
                        filtered_rows.append(row)
                except (ValueError, KeyError) as e:
                    print(f"Warning: Skipping invalid row: {e}", file=sys.stderr)
                    continue
        
        # Write filtered output
        with open(output_csv, 'w', encoding='utf-8', newline='') as outfile:
            writer = csv.DictWriter(outfile, fieldnames=fieldnames)
            writer.writeheader()
            writer.writerows(filtered_rows)
        
        print(f"Filtered {len(filtered_rows)} characters matching types [{', '.join(type_list)}] from {input_csv} to {output_csv}")
        
    except FileNotFoundError:
        print(f"Error: Input file '{input_csv}' not found.", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description='Filter character CSV file by character type (ASCII, CJK, upper, lower, number, common_cjk).'
    )
    parser.add_argument(
        'input_csv',
        help='Input CSV file generated by dump_char_csv.py'
    )
    parser.add_argument(
        'type',
        help='Comma-separated character types to filter: ascii, cjk, upper, lower, number, common_cjk (e.g., "upper,lower,number")'
    )
    parser.add_argument(
        'output_csv',
        help='Output filtered CSV file'
    )
    
    args = parser.parse_args()
    
    filter_csv(args.input_csv, args.type, args.output_csv)


if __name__ == '__main__':
    main()
